# C++ Programming Tsinghua
## Metadata
- ItemType: book
- Authors: [[ Haoqiang Tan]]
- Collection: [[C++]]
- Date: 2022-08
- PDF Attachments: [C++程序设计第3版 (谭浩强) (z-lib.org).pdf](zotero://open-pdf/library/items/ECYG9VVR)
- Tags: #reading

👣➿👣

#### 第二章-变量
![[Pasted image 20220902102930.png|775]]
- 指针变量分配四个字节的存储空间


## 第四章-数组
- 一个数组，一种数据类型
- 数组的大小不能是变量，一定是一个固定的值，可以是int a[5]; 或者 const int n=5; int a[n];
- 一维数组只能逐个引用值，如a[0]=a[5]+a[7];
- 数组可以引用也可以赋值，如上例，二维数组是一样的
- 范围要注意：声明语句int a[3]\[4]; （数组三行四列）后面不能引用a[3]\[4] 没有这个元素；即前者表示维数或者说长度，后者代表下标值（从零开始）
- **数组名**作为函数**实参或形参**时传递的是数组的**起始地址**（首元素的地址），因此形参也可以是指针变量来存放地址
- 函数参数&数组：
	1. 数组元素为函数实参：此时只是把实参变量的值传给形参变量；形参变量修改，不影响实参变量/原数组
	2. 数组名为函数实参：引用时fun(a,5) // 5 is length，定义时void fun(int a[], int n)，即形参为数组名或者指针变量
		- 函数形参为数组名时，那么实参数组和形参数组共享一段内存；形参数组修改后，实参数组也被修改；然而形参变量和实参变量是不会的
		- 函数定义时，int a[] 只代表一维数组并接收首元素地址，并不分配内存单元，长度参数无意义
- 字符数组：
	- 字符串总是和字符数组联系起来，为了存放字符串必须定义字符数组
	- 字符串结束标志：'\0'（ASCII码为0的字符，空操作符，不显示，什么也不干） 通过它的位置确定字符串长度
	- 赋值三种：
		1. char c[5]={'I','a','m','Y','D'}; 初始化赋值
		2. char c[]="IamYD";  用字符串常量来初始化字符数组，其长度为6（系统自动加空字符）
		3. char c[5]; c[0]='I'; ... 即逐个赋值
	- 输入输出两种：
		1. int str[20]; cin>>str; cout<\<str; 用字符数组名str输入输出字符串，代表首元素的地址
		2. 逐个字符输入输出
	- 形参设定最好：void top_country(char country[]\[20], int n)  其中不指定第一维大小（即国家的个数n），设置一个形参n来表示个数
- 字符串类string 以及 字符串变量（对象）：
	- 基本类型包括：char、int、float、double
	- string是在标准库中声明的字符串类，以类定义对象
	- 好处：定义时不需要指定长度，不必担心overflow；可以赋值；可以通过index修改某个字符；cin和cout
	- 运算：不需要特定函数，和python一样；原因：基本运算符的重载
	- 字符串数组：字符串组成
	- char array，string，string array声明见code


## 第五章-指针

#### 地址、内容、变量名、指针：
- 地址：内存区的每一个字节有一个编号，如存储int变量须四个字节，2000~2003；旅馆的房间号
- 直接存取/访问法：
	- 编译时，将变量名（i）转换为变量的地址（2000以后四个字节）；
	- 通过地址对内存单元进行存取操作；
	- 用A钥匙直接打开A抽屉，拿出A中的东西；
- 间接存取/访问法：
	- 将变量（i）的地址存放在另一个变量中
	- 为保险起见，将A钥匙放在B抽屉；先找出B钥匙，打开B抽屉，取出A钥匙，打开A抽屉，拿出A中的东西
- 指向：地址指向变量单元；i_pointer存放i变量的起始地址，指向变量i；通过1001号码就可以找到的1001房间
- 指针：地址即指针，一种形象话说法；
- 指针变量：
	- 目的：专门用来存放地址（即指针）的变量；用来指向常规的变量；
	- 举例：i_pointer是一个指向整型变量的指针变量；i的指针是2000，i的指针变量是i_pointer；
	- 指向符*：* i_pointer=3 和 i=3 一样的；表示该变量是指针变量
	- 定义：**基类型 * 指针变量名**；
		- 如 int * pointer表示该指针变量只能存放指向整型数据的地址，不能是float数据
		- int指针（int * ）、char指针、float 指针
	- 基类型（如int，float，char）：
		- 该指针变量所指变量的类型
		- 必要性：不同类别数据存储方式和空间都不同，得到地址后具体取几位、怎么取决定于基类型；指针+1对不同类型的移动方式都不同；是基本数据类型派生出来的类型；
	- 取地址运算符&：&a
- 指针操作的好处：
	- 函数：通过调用函数，实现main中变量的改变；而不用指针的话，就是单向的值传递过程，只有形参被修改而实参不会改动，函数调用时实参和形参的关系是单向的值的传递
	- 你把要修改的变量的地址传到函数里，在函数里通过地址修改原变量的值
	- 这样的好处是不用麻烦的列出函数的许许多多返回值了，可以直接void就行

#### 指针与数组
- 指向数组元素的指针：
	- 数组元素的指针就是数组元素的地址
	- 数组名a为首地址，可以直接赋给指针变量
	- a+i就是a[i]的地址，\*a[i]可以访问或者修改这个元素，等价于a[i]
	- 变地址运算符[]：a\[i]=\*(a+i)，p\[i]=\*(p+i)，即当前地址+i取元素，这些处理在编译时进行，这两者是无条件等价的
	- 引用一个数组元素：下表法a[i]与指针法*(p+i)，这两种运算效率一样，但++p方法的运算效率高
	- **滚动指针变量p**：通常令指针变量先存首地址，然后p++，这样就不用多次计算地址，速度快
	- int a[5], \*p=a, i; for (i=0;i<5;i++){ cin>>\*p++; } p=a; for (i=0;i<5;i++){ cout<<\*p++; }
	- 再次强调：滚动法的最大问题就是忘记把p归零到a！
	- 指针法优点：占内存少，运行速度快
- 指针变量作函数形参接受数组地址：
	- 用一个p作为形参，接收首地址（数组名）a
	- sizeof(int)=4, sizeof(int*)=8
	- 以下为两种常见的形参考虑数组的情况
		- 数组名作形参$void~select\_sort(int~arr[~],int~n)$：形参数组与实参数组共同占用一段内存单元，调用时改变形参数组也会改变实参数组的值；编译时按照指针变量处理相当于$void~select\_sort(int *arr,int~n)$，也就是说**形参数组名本质上是个指针变量**
		- 补充：由于形参数组名本质上是指针变量，并没有真正开辟数组存储空间，所以指定长度没有任何意义
		- 指针变量作形参$void~select\_sort(int~*p,int~n)$：专业高效，但可能不便于理解
		- 再次强调：a[i]与\*(a+i)无条件等价
		- 然而实参咱们就用数组名就好了
	- Note：实参数组名a代表固定的地址，值不可以改变，是指针常量；一定要把它赋给p，让p动态变化；然而，形参数组名不是一个固定的地址，按指针变量处理
	- ![[Pasted image 20220911220754.png]]
	- 函数与指针：
		- 函数指针$int~(*p)(int,int)$ ，一定要加括号是因为p先与\*结合表示指针变量，表示含参为int返回值为int的函数的指针变量
		- 如无括号，$int~*p(int,int)$，表示声明函数，返回一个int  * 指针
	- 指针数组：
		- 数组的元素均为指针类型数据，每一个元素都是指针变量，值为地址
		- int * p[4]，每个数组元素指向整型变量

#### 特殊的指针
- const 指针：
	- 指向常量的指针变量：const int * p=&a，定义了p为指向整型变量的const指针变量、
		- 不能通过p改变变量a的值
		- p可以指向别的比如b、
	- 常指针：int * const p=&a
		- 指针变量的指向不能改变
		- 但指向的整型变量的值可以改变
	- 指向常量的常指针：const int * const p=&a
		- 前两者的结合
- void指针：
	- 指向空类型的指针，是开辟空间的，过度类型的
	- void指针可以强制转换为其他类型的指针
- 使用指针的优点：
	- 提高程序效率
	- 通过调用函数，改变主调函数的指
	- 实现动态存储分配

#### 引用reference
- 作用：为一个变量起一个别名
- int a; int &b=a; 通过b可以引用a
- &: 引用声明符，不代表地址
- 对引用只有声明，没有定义，先定义一个变量，然后声明对变量的引用
- 声明的同时作初始化，即声明为哪一个变量
- a的值总是和b的值一起变化
- 函数中形参作引用：
	- 函数形参是引用，而函数实参是整型变量，那么虚实结合时就建立了引用关系，两边指的是一个东西，同时修改
	- 实参是变量名，然而传递的是地址
	- 和传统实参形参不同，传统的只是传递了**实参的值**，而这里是建立了引用关系（传递地址）
	- 调用函数分类：传值方式、传址方式
	- OOP中，实参可以是类对象名，而传递的是类对象的起始地址
- cin和cout的适用类型：
	- cin：指向的变量（不能是指针变量会报错），普通变量，a[i]
	- cout：指向的变量（如果是指针变量输出的是地址），普通变量, a[i]

![[Pasted image 20220904162031.png|775]]
#### 多维数组的指针
- 多维数组元素的地址：
	- 二维数组：每一个行元素是一维数组
	- 下列表达式的含义：
		- a：二维数组首元素的地址=首行一维数组的起始地址；2000
		- a+1：第1行（序号为1）的起始地址；a+1指向a\[1]；2000+4\*4=2016
		- a\[0]： 一维数组名，代表一维数组a\[0]中的第0列元素的地址；a\[0]=&a\[0]\[0];
		- a\[1]：同理，a\[1]=&a\[1]\[0];
		- a\[0]+1：即0行1列元素的地址；a\[0]+1=&a\[0]\[1]
	- 地址的等量关系：
		- 由恒等式：a\[i] == \*(a+i)；a\[i]是一维数组名，只是一个地址，并不代表一个存储单元
		- &a\[i]\[j] == a\[i]+j == \*(a+i)+j
	- 元素a\[i]\[j]的多种表示：
		- \*(a\[i]+j) 与 \*(\*(a+i)+j)
	- 运算符\*的两种含义：（区分**指向行的地址**和**指向元素的地址**）
		- 取列，如\*(a+1)：
			- 对行指正取列，得到元素指针
			- a+1是第一行的起始地址，并不是某个数组元素的地址，所以谈不上取存储单元的内容；
			- 这里指的是a\[1]，根据恒等式a\[i]=\*(a+i) ，是一维数组名，所以是a\[1]\[0]的元素地址
			- 对于行指针，加\*就意味着转换为元素指针，如\*a和\*(a+1)；总之，取列和使用恒等式是一个道理
		- 取内容，如\*(a\[0]+1)：
			- a\[0]本身是0行0列元素的地址，a\[0]+1是0行1列元素的地址，\*(a\[0]+1)就可以对存储单元提取内容了，代表0行1列元素的值
			- 例：a\[1]\[0]=\*(\*(a+1)+0)，先取列再取内容
	- 运算符&的两种含义：
		- 取行，如&a\[0]：
			- 对元素指针取行，得到行指针
			- &a\[0] == &\*a == a都是代表0行指针，因为a\[0] == \*a 
			- 为什么是取行？因为并不存在a\[0] 这样一个实际的数据存储单元
		- 取地址，如&a\[0]\[0]：
			- 对数据存储单元取地址
			- &a\[i]\[0]是元素地址，基类型为int \*p
	- a和a\[0]的区别：
		- 纯地址是相同的（如都是2000）；所指向的数据的类型信息是不同的，基类型不同
		- 前者指向0行（一维数组），适用的指针变量：int (\*pa)\[4]，指针指向一维数组，该数组有四个整型数据
		- 后者指向0行0列（整型数据），适用的指针变量：int \*p，指针指向整型数据
		- 排长指向班，班长指向战士
![[Pasted image 20220911232213.png]]
![[Pasted image 20220911225757.png|1200]]
- **指向数组元素**的指针变量：
	- 指针变量类型：int *
	- 二维数组内存存放：按行存放，相当于在内存中被flatten了，于是指针变量p可以不断p++
	- 若p初始话为a\[0]，那么i行j列元素（0记法）的地址是p+i\*n+j，其中i\*n+j为相对位移
- **指向一维数组**的指针变量
	- 指针变量类型：int (\*)\[4]（4是指一维数组长度）
	- int a\[]\[4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}}; int r,c,(\*pr)\[4]=a; cin>>r>>c; cout<<\*(\*(pr+r)+c);
- 用**指向数组的指针**作函参
	- 指针变量两种类型：元素指针变量或者行指针变量


#### 字符、字符串与字符指针
- 字符常量：'a'
	- getchar、putchar：单个字符的输入及输出；原C语言用法；getchar()无参；putchar(c)单个字符；while ((c=getchar()!='\\n')){}
- 字符串常量："asdf"
	- 用字符数组存放；最后会加'\\0'
	- scanf、printf：原C语言用法；scanf("%d, %f, %c", &a, &b, &c) 要加地址运算符; printf("%d, %f, %c", a, b, c);
- 字符数组（C-string）：每个元素存放一个字符；原C语言用法
	- 初始化定义：用字符串常量初始化；char str[]="I am happy";
	- 对元素修改：str[0]='H';
	- 测长度：strlen(str)；真实长度，不包含结束标志'\\0'
	- 输入：cin>>str;  即字符串首地址；对于二维数组char str[3]\[20]; cin>>str[i];
	- 输出：cout<\<str; 不会输出'\\0'，输出字符串真实长度；对于二维数组char str[3]\[20]; cout<<str[i];
	- 字符数组连接：strcat(char[], const char[]) 两个参数均为字符数组首地址；第一个数组被加长，返回第一个数组首地址
	- 字符数组复制：strcpy(char[], const char[], int) 参数为字符数组首地址，第三个可加为长度；覆盖数组1
	- 字符数组比较：strcmp(const char[], const char[])，接收字符数组首地址；返回>0,=0,<0，理解为左值减去右值 
	- 二维数组：如char str[3]\[20]; str[0], str[1], str[2]都是字符串首地址，可以cin, cout
		- 赋初值：char name\[n][10]={"Yida","Heyun","Heqing","Runzhe"};
		- 输入输出：char str[n]\[30]; for (i=0;i<n;i++){ cin>>str[i]; }
		- 用指向数组的指针：char (\*p)\[20]=str;
		- 用指针变量输出：cout<<\*p<<endl; 即指针变量p所指向的一维字符数组
	- 二维数组形参：void small_str(char str\[]\[30], int n);
- 字符指针：
	- 直接初始化：const char \*p="hello"; 必须加const才能不报错
	- 初始化定义：char str1[20]="China", str2[20]; char \*p1=str1,\*p2=str2; 指向字符数组的首地址
	- 输出：cout<<p2<<endl; 指针需要指向字符数组的首地址

- 字符串类与字符串变量（String）：C++标准库
	- 背景：用字符数组存放字符串可能会溢出；使用字符串类型（string）更安全方便
	- 初始化定义：string str1="China";
	- 赋值（复制）：str2=str1; str1="Canada";
	- 输入输出：cin>>str1; cout<\<str1; 直接用字符串变量名
	- 字符串连接：str2+=str1;
	- 字符串比较：\==, >=, <=
- 字符串数组：
	- 每一个元素为一个字符串；不要求各字符串等长
	- string name[3]={"Yida","Heyun","Runzhe"};
	- 输入：for (i=0;i<n;i++){ cout<<"Enter name and id: "; cin>>name[i]>>num[i];
- 指向字符数组的指针：
	- 对于二维字符数组好用：char course\[5]\[10], (\*p)\[10]; p=course; for (i=0;i<5;i++){cin>>course\[i];}
	- 指针变量赋初值为二维数组首地址，之后
- 指针数组（各指针指向字符串）：
	- 初始化：同字符指针
	- const int n=4; char name\[n][10]={"Yida","Heyun","Heqing","Runzhe"}; char \*ps[n],\*ptemp;
	- int i; for (i=0;i<n;i++){ ps[i]=name[i]; }


### 指向函数的指针
- 编译时，把函数的源码转换为可执行代码并分配内存空间；有一个起始地址（函数入口地址，函数名代表）；调用函数时，从函数名得到函数的起始地址，并执行函数代码
- 可以定义一个指向函数的指针变量，用来存放某一函数的起始地址，如int (\*p)(int,int)
- 重要应用：主调函数形参设置为这类指针变量
	- 把其他函数的函数名（入口地址）作为实参传给主调函数
	- 主调函数这次可以调用f1，下次调用f2，再下次f3
	- 典型案例：compute definite integral

### 返回指针值的函数
- 形式：int \*fun(int x, int y)
- 核心用途：如果你本来想返回一行或者一个一维数组，那你可以返回这一行的首行地址，一般为元素地址，通过它可以在主调函数中打印出这一整行

### 指针数组与多重指针
- 形式：int \*pa\[4]; 表示pa是一个数组，里面包含int\*指针
- 注意和int (\*p)\[4]区分，这是一个行指针，指向长度为4的一维数组
- 核心用途：指向若干个字符串
- 

### 动态内存分配


👣➿👣